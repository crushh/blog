<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XMLHttpRequest对象</title>
    <url>/2021/01/30/XMLHttpRequest%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>以下简称：XHR</p>
<h2 id="干嘛用的："><a href="#干嘛用的：" class="headerlink" title="干嘛用的："></a>干嘛用的：</h2><p>为服务器发送请求和解析服务器响应提供了流畅的接口。能够以异步的方式从服务器获得更多信息，意味着用户单击后不用刷新页面也可以取得新数据。也就是说，ajax技术中使用XHR对象取得新数据，再通过DOM将新数据插入页面中。</p>
<h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr=new XMLHttpRequest();</span><br><span class="line">xhr.open(‘要发送的请求类型’，‘请求的url’，是否异步发送的布尔值)；</span><br><span class="line">//没真发，就是启动一个请求以备发送</span><br><span class="line">xhr.send();//真发了</span><br></pre></td></tr></table></figure>
<p>收服务器响应后，响应的数据会自动填充XHR对象的属性，如下</p>
<p>responseText：作为响应主体被返回的文本；<br>responseXML：如果响应的主体是’text&#x2F;xml‘or’application&#x2F;xml‘，这个属性中将保存着响应数据的XML DOM文档；<br>status：响应的http状态。如：404，200<br>statusText:Http状态的说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr=new XMLHttpRequest();</span><br><span class="line">xhr.open(‘get’，‘/post.jsonl’，true)；</span><br><span class="line">xhr.send();</span><br><span class="line">if((xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300)||xhr.status==304)&#123;</span><br><span class="line">  alert(xhr.responseText);</span><br><span class="line">&#125;else&#123;</span><br><span class="line"> alert(xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有些xhr属性，如：<br>readyState：表示请求&#x2F;响应过程的活动阶段，可取的值如下<br>0:未初始化。还没调用open方法。<br>1：启动。调用了open还没send。<br>2：发送。调用了send，还没收到响应。<br>3：接收。已经接收部分数据。<br>4：完成。接收完毕所有响应数据。<br>只要readyState一改变就触发readystatechange事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr=new XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=function()&#123;</span><br><span class="line">if(xhr.readyState==4)&#123;</span><br><span class="line">    if((xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300)||xhr.status==304)&#123;</span><br><span class="line">         alert(xhr.responseText);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        alert(xhr.status);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line">xhr.open(‘get’，‘/post.jsonl’，true)；</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Http头部信息"><a href="#Http头部信息" class="headerlink" title="Http头部信息:"></a>Http头部信息:</h5><p>自定义http头部信息，为啥要设置这个的建议去看http图解一书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(&quot;头部字段&quot;, &quot;头部字段的值&quot;);</span><br><span class="line">把这个放在open和send中间使用。</span><br><span class="line">xhr.getResponseHeader(&quot;头部字段&quot;)：得到相应的值。</span><br><span class="line">xhr.getAllPesponseHeaders();</span><br><span class="line">//得到一个包含所有头部信息的长字符串。</span><br></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>最常见用于想服务器查询某些信息。对于xhr来说，url末尾的查询字符串必须经过正确的编码才行。<br>tips：所有名-值对儿都必须由&amp;分开。<br>查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;,&quot;example.php?name1=value1&amp;name2=value2&quot;,true);</span><br></pre></td></tr></table></figure>
<p>可以使用这个函数来帮助向现有url末尾添加查询字符串参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addURLParam(url,name,value)&#123;</span><br><span class="line"> url+=(url.indexOf(&quot;?&quot;)==-1&quot;?&quot;:&quot;&amp;&quot;);</span><br><span class="line"> url+=encodeURIComponent(name)+&quot;=&quot;+encodeURIComponent(value);</span><br><span class="line">return url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面结合实际例子来使用这个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addURLParam(url,name,value)&#123;</span><br><span class="line"> url+=(url.indexOf(&quot;?&quot;)==-1&quot;?&quot;:&quot;&amp;&quot;);</span><br><span class="line"> url+=encodeURIComponent(name)+&quot;=&quot;+encodeURIComponent(value);</span><br><span class="line">return url;</span><br><span class="line">&#125;</span><br><span class="line">var url=&quot;example.php&quot;;</span><br><span class="line"> url=addURLParam(url,&quot;name&quot;,&quot;yourfather&quot;);</span><br><span class="line"> url=addURLParam(url,&quot;book&quot;,&quot;yourpornbook&quot;);</span><br><span class="line"> xhr.open(&quot;get&quot;,url,false);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function submitData()&#123;</span><br><span class="line">var xhr=new XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange=function()&#123;</span><br><span class="line">if(xhr.readyState==4)&#123;</span><br><span class="line">    if((xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300)||xhr.status==304)&#123;</span><br><span class="line">         alert(xhr.responseText);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        alert(xhr.status);</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(&quot;post&quot;,&quot;example.php&quot;,true);</span><br><span class="line">xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//表单提交时的内容类型</span><br><span class="line">var form=document.getElementById(&#x27;user-info&#x27;);</span><br><span class="line">xhr.send(serialize(form));</span><br><span class="line">//而在XMLHttpRequest2中规定了</span><br><span class="line">FormData对象</span><br><span class="line">new 一个FormData对象后，xhr.send(new FormData(form));</span><br><span class="line">这样就不需要手动写请求头</span><br></pre></td></tr></table></figure>
<h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4><p>除了ie定义了一个XDR(XDomainRequest)类型外，其他主流浏览器都可以直接用标准的XHR对象来实现跨域请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createXHR()</span><br><span class="line">&#123;</span><br><span class="line">    if (typeof XMLHttpRequest != &quot;undefined&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">        return new XMLHttpRequest();</span><br><span class="line">    &#125; // end if</span><br><span class="line">    else if (window.ActiveXObject)</span><br><span class="line">    &#123;</span><br><span class="line">        var aVersions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;];</span><br><span class="line">        for (var i = 0; i &lt; aVersions.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                var oXHR = new ActiveXObject(aVersions[i]);</span><br><span class="line">                return oXHR;</span><br><span class="line">            &#125; // end try</span><br><span class="line">            catch (oError)</span><br><span class="line">            &#123;</span><br><span class="line">                // do nothing</span><br><span class="line">            &#125; // end catch</span><br><span class="line">            </span><br><span class="line">        &#125; // end for</span><br><span class="line">        </span><br><span class="line">    &#125; // end else if</span><br><span class="line">    </span><br><span class="line">    throw new Error(&quot;XMLHttp object could not be created.&quot;)</span><br><span class="line">    </span><br><span class="line">&#125; // end createXHR();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var xhr= createXHR();</span><br><span class="line">xhr.onreadystatechange=function()&#123;</span><br><span class="line">if(xhr.readyState==4)&#123;</span><br><span class="line">    if((xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300)||xhr.status==304)&#123;</span><br><span class="line">         alert(xhr.responseText);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        alert(xhr.status);</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> xhr.open(&quot;get&quot;,&quot;http://www.somewhere-else.com/page/&quot;,true);</span><br><span class="line"> xhr.send();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>http缓存</title>
    <url>/2020/03/01/http%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><ul>
<li>强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。</li>
<li>协商缓存：浏览器发送请求到服务器，服务器判定是否可使用本地缓存。</li>
</ul>
<p><img data-src="https://img-blog.csdnimg.cn/20190710110344662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NydXNoaF9mdW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="强制刷新"><a href="#强制刷新" class="headerlink" title="强制刷新"></a>强制刷新</h3><p>这会使浏览器重新去服务器请求资源再加载。</p>
<p>IE强制刷新：CTRL+F5。</p>
<p>FireFox强制刷新：CTRL+F5，CTRL+SHIFT+R</p>
<p>Chrome强制刷新：CTRL+SHIFT+R</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>post提交数据的四种编码方式</title>
    <url>/2019/11/30/post%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="application-x2F-x-www-form-urlencoded"><a href="#application-x2F-x-www-form-urlencoded" class="headerlink" title="application&#x2F;x-www-form-urlencoded"></a>application&#x2F;x-www-form-urlencoded</h3><p>传表单格式<br>键值对。</p>
<h3 id="multipart-x2F-form-data"><a href="#multipart-x2F-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h3><p>能传文件，不仅仅是表单数据<br>这也是一种比较常见的post数据格式，我们用表单上传文件时，必须使form表单的enctype属性或者ajax的contentType参数等于multipart&#x2F;form-data。使用这种编码格式时发送到后台的数据长得像这样子<br><img data-src="https://img-blog.csdnimg.cn/20191103203942685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NydXNoaF9mdW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我把值json.Stringify(val)了。<br>演示下，如果需要用post发送formdata格式的数据该如何配置。背景是因为我们要上传一个超长的数组。<br>在封装好axios请求也就是写好了请求拦截器后，在api文件中这样封装<br><img data-src="https://img-blog.csdnimg.cn/20191103204307145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NydXNoaF9mdW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用时这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let param = new FormData(); //创建form对象</span><br><span class="line">              param.append(&#x27;chatRecord&#x27;,JSON.stringify(this.msgList));//你要传的键名，值 因为我要传一个数组 所以先转换成json字符串</span><br><span class="line">			commitChat(this.consultId,param).then(res=&gt;&#123;</span><br><span class="line">				console.log(res.data)</span><br><span class="line">			&#125;)</span><br></pre></td></tr></table></figure>
<p>如果没有封装，直接写，可以参考下面的写法：<br>日后有空补充，反正和封装的差不多</p>
<h3 id="application-x2F-json"><a href="#application-x2F-json" class="headerlink" title="application &#x2F; json"></a>application &#x2F; json</h3><p>如果使用這種編碼方式，那麼傳遞到後台的將是序列化後的json 字符串。我們可以將application &#x2F; json與application &#x2F; x-www-form-urlencoded發送的數據進行比較</p>
<h3 id="text-x2F-xml"><a href="#text-x2F-xml" class="headerlink" title="text&#x2F;xml"></a>text&#x2F;xml</h3><p>传纯粹的文本，就是字符串。这种格式我没有怎么使用过。</p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp-拥塞控制</title>
    <url>/2019/07/10/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>作用于网络，防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用方法：</p>
<ul>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ul>
<h3 id="慢开始："><a href="#慢开始：" class="headerlink" title="慢开始："></a>慢开始：</h3><p>开始：cwnd的大小被设置为最大报文段MSS的数值<br>               发送方发送一个cwnd(congestion window)<br>               收到确认后，cwnd数量加倍（1，2，4，8….）</p>
<p> 但是：为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限ssthresh状态变量  ，用法如下     </p>
<pre><code>  当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。

  当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。

  当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。
</code></pre>
<p><img data-src="https://img-blog.csdnimg.cn/20190710092610762.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NydXNoaF9mdW4=,size_16,color_FFFFFF,t_70" alt="一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。"></p>
<h3 id="拥塞避免算法："><a href="#拥塞避免算法：" class="headerlink" title="拥塞避免算法："></a>拥塞避免算法：</h3><h5 id="每经过一个往返时间RTT-就把发送方的cwnd-1而不是加倍。"><a href="#每经过一个往返时间RTT-就把发送方的cwnd-1而不是加倍。" class="headerlink" title="每经过一个往返时间RTT 就把发送方的cwnd+1而不是加倍。"></a>每经过一个往返时间RTT 就把发送方的cwnd+1而不是加倍。</h5><p><img data-src="https://img-blog.csdnimg.cn/2019071009342638.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NydXNoaF9mdW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>发送方判断出现拥塞：将ssthresh设置为出现拥塞时发送方窗口值的一半但不小于2，然后将cwnd重设为1，执行慢开始算法。</p>
<h3 id="快重传算法"><a href="#快重传算法" class="headerlink" title="快重传算法"></a>快重传算法</h3><h5 id="要求接收方每收到一个失序的报文段后就立即发出重复确认-不要等到自己发送数据时才进行捎带确认。"><a href="#要求接收方每收到一个失序的报文段后就立即发出重复确认-不要等到自己发送数据时才进行捎带确认。" class="headerlink" title="要求接收方每收到一个失序的报文段后就立即发出重复确认,不要等到自己发送数据时才进行捎带确认。"></a>要求接收方每收到一个失序的报文段后就立即发出重复确认,不要等到自己发送数据时才进行捎带确认。</h5><p><img data-src="https://img-blog.csdnimg.cn/20190710102522735.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NydXNoaF9mdW4=,size_16,color_FFFFFF,t_70"></p>
<p>快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。</p>
<p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<h3 id="快恢复算法"><a href="#快恢复算法" class="headerlink" title="快恢复算法"></a>快恢复算法</h3><p>（1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。</p>
<p>（2）由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>
<p><img data-src="https://img-blog.csdnimg.cn/2019071010315769.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NydXNoaF9mdW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>参考链接:<a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html">http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html</a><br><a href="https://blog.csdn.net/yechaodechuntian/article/details/25429143">https://blog.csdn.net/yechaodechuntian/article/details/25429143</a></p>
]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>this的指向</title>
    <url>/2019/08/01/this%E7%9A%84%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h2 id="this既不指向函数自身，也不指向函数的作用域，它指向什么完全取决于函数在哪被调用。"><a href="#this既不指向函数自身，也不指向函数的作用域，它指向什么完全取决于函数在哪被调用。" class="headerlink" title="this既不指向函数自身，也不指向函数的作用域，它指向什么完全取决于函数在哪被调用。"></a>this既不指向函数自身，也不指向函数的作用域，它指向什么完全取决于函数在哪被调用。</h2><h4 id="方法调用模式（the-method-invocation-pattern）又称为隐式绑定"><a href="#方法调用模式（the-method-invocation-pattern）又称为隐式绑定" class="headerlink" title="方法调用模式（the method invocation pattern）又称为隐式绑定"></a>方法调用模式（the method invocation pattern）又称为隐式绑定</h4><p>当一个函数被保存为一个对象的属性时，被称为‘方法’。当一个方法被调用时，this被绑定到该对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;      console.log( this.a ); &#125; </span><br><span class="line"> </span><br><span class="line">var obj = &#123;      a: 2,     foo: foo  &#125;; </span><br><span class="line"> </span><br><span class="line">obj.foo(); // 2</span><br></pre></td></tr></table></figure>
<p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;      console.log( this.a ); &#125; </span><br><span class="line"> </span><br><span class="line">var obj2 = &#123;      a: 42,     foo: foo  &#125;; </span><br><span class="line"> </span><br><span class="line">var obj1 = &#123;      a: 2,     obj2: obj2  &#125;; </span><br><span class="line"> </span><br><span class="line">obj1.obj2.foo(); // 42</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>tips：隐式丢失：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;      console.log( this.a ); &#125; </span><br><span class="line"> </span><br><span class="line">var obj = &#123;      a: 2,     foo: foo  &#125;; </span><br><span class="line"> </span><br><span class="line">var bar = obj.foo; // 函数别名！ </span><br><span class="line">var a = &quot;oops, global&quot;; // a 是全局对象的属性 </span><br><span class="line"> </span><br><span class="line">bar(); // &quot;oops, global</span><br></pre></td></tr></table></figure>
<p>这时候的bar只是引用了foo函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>
<h4 id="函数调用模式-the-function-invocation-pattern-又称为-默认调用"><a href="#函数调用模式-the-function-invocation-pattern-又称为-默认调用" class="headerlink" title="函数调用模式(the function invocation pattern)又称为 默认调用"></a>函数调用模式(the function invocation pattern)又称为 默认调用</h4><p>当函数并未一个对象的属性时，它被当作一个函数来调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">      console.log( this.a ); </span><br><span class="line">&#125;</span><br><span class="line">var a = 2;  </span><br><span class="line">foo(); // 2 </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。虽然 this 的绑定规则完全取决于调用位置，但是只 有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;      &quot;use strict&quot;; </span><br><span class="line"> </span><br><span class="line">    console.log( this.a );  &#125; </span><br><span class="line"> </span><br><span class="line">var a = 2; </span><br><span class="line"> </span><br><span class="line">foo(); // TypeError: this is undefine</span><br></pre></td></tr></table></figure>

<h4 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h4><p>如果函数倾向于和 new 关键词一块使用，则我们称这个函数是 构造函数。 在函数内部，this 指向新创建的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Quo=function (string)&#123;</span><br><span class="line">   this.status=string;</span><br><span class="line">&#125;</span><br><span class="line">//给Quo的所有实例提供一个名为get_status的公共方法</span><br><span class="line">Quo.prototype.get_status=function()&#123;</span><br><span class="line">return this.status;</span><br><span class="line">&#125;;</span><br><span class="line">var myQuo=new Quo(&#x27;confused&#x27;);</span><br><span class="line">document.writeln(myQuo.get_status());//confused</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo(a) &#123;      this.a = a; &#125;  </span><br><span class="line"> </span><br><span class="line">var bar = new foo(2); console.log( bar.a ); // 2</span><br></pre></td></tr></table></figure>
<h4 id="apply-or-call-调用模式（显式绑定）"><a href="#apply-or-call-调用模式（显式绑定）" class="headerlink" title="apply or call 调用模式（显式绑定）"></a>apply or call 调用模式（显式绑定）</h4><p>这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我 们称之为显式绑定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo() &#123;      console.log( this.a ); &#125; </span><br><span class="line"> </span><br><span class="line">var obj = &#123;      a:2 &#125;; </span><br><span class="line"> </span><br><span class="line">foo.call( obj ); // 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现 在其他的参数上，但是现在我们不用考虑这些。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol>
<li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 var bar &#x3D; new foo()</li>
<li>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 var bar &#x3D; foo.call(obj2)</li>
<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 var bar &#x3D; obj1.foo()</li>
<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 var bar &#x3D; foo()</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>关于如何监控vuex里对象的属性变化</title>
    <url>/2021/03/02/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7vuex%E9%87%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<p>我有一个这样的数据结构，在store里有一个msgList的对象，属性是用户的username，要在每次这个用户发出一条消息记录时push一个新元素进去，并响应这个变化，同时更新当前对话记录。<br><img data-src="https://img-blog.csdnimg.cn/20191101164540175.png" alt="在这里插入图片描述"><br><a href="https://cn.vuejs.org/v2/guide/list.html#">https://cn.vuejs.org/v2/guide/list.html#</a><br>这是官方写的对于数组，对象属性更新检测的注意事项。我自己使用了其中的Object.assign()，来实现响应。</p>
<p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
<p>官方要求我们用这种写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">  age: 27,</span><br><span class="line">  favoriteColor: &#x27;Vue Green&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>是因为如果使用下列这种写法，只是复制了源目标的值，引用地址并没有变化，本质还是属性的修改，无法检测。而上面写法相当于换了一个对象，自然就能检测到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.assign(vm.userProfile, &#123;</span><br><span class="line">  age: 27,</span><br><span class="line">  favoriteColor: &#x27;Vue Green&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>预备知识讲完，进入正题。<br>在mutations里先按照普通写法，将userName作为一个对象的一个属性，并给属性赋值一个被放到数组里的payload对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const state=&#123;</span><br><span class="line">    msgList:&#123;&#125;,//所有消息集合</span><br><span class="line">&#125;;</span><br><span class="line">const mutations=&#123;</span><br><span class="line">updateMsgList(state,payload)&#123;</span><br><span class="line">	console.log(payload)</span><br><span class="line">	if(payload.bySelf===true)&#123;//我方发给对方 存储发送消息的To 作为username</span><br><span class="line">		if(!state.msgList[payload.to])&#123;//第一次给对方发消息 第一次建立username属性</span><br><span class="line">		state.msgList[payload.to]=[&#123;</span><br><span class="line">			...payload</span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		state.msgList[payload.to].push(&#123;</span><br><span class="line">			...payload</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;else&#123;//对方给我方发送消息  存储接收消息的from作为username</span><br><span class="line">if(!state.msgList[payload.from])&#123;//第一次给对方发我方消息 第一次建立username属性</span><br><span class="line">		state.msgList[payload.from]=[&#123;</span><br><span class="line">			...payload</span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		state.msgList[payload.from].push(&#123;</span><br><span class="line">			...payload</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	state.msgList = Object.assign(&#123;&#125;, state.msgList);</span><br><span class="line">	//这就是关键，将普通不会被检测到的对象变成可以被检测到的对象，因为每次都把源目标给了一个新对象</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在组件里 这样写 用computed 获得一个响应msgList变化的变量  再在watch中监视这个变量 当这个变量变化时 做一些操作.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	computed:&#123;</span><br><span class="line">...mapGetters(&#123; //记得引入vuex</span><br><span class="line">         	   stateMsgList:&#x27;GetmsgList&#x27; //绑getters时 当msglist变化时 监听到这个对象的变化,我试着直接绑定state.msgList 但是当msgList变化时 没有监听到变化</span><br><span class="line">            &#125;),</span><br><span class="line">            &#125;，</span><br><span class="line">            watch:&#123;</span><br><span class="line">			stateMsgList:function(val) &#123;</span><br><span class="line">		         this.getCurrentMsg();//当msgList变化时 更新当前聊天记录的方法</span><br><span class="line">		      &#125;</span><br><span class="line">		&#125;,</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>新手向</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序-setData问题</title>
    <url>/2019/10/28/%E5%B0%8F%E7%A8%8B%E5%BA%8F-setData%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onLoad:function(options)&#123;</span><br><span class="line">	 const that=this; </span><br><span class="line">	wx.request(&#123;</span><br><span class="line">		url:&#x27;你的接口地址&#x27;,</span><br><span class="line">		success(res)&#123;	</span><br><span class="line">			console.log(res.data.data.recommendList)</span><br><span class="line">			const recommendList=res.data.data.recommendList;</span><br><span class="line">			that.setData(&#123;</span><br><span class="line">				banner:recommendList</span><br><span class="line">			&#125;)</span><br><span class="line">  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>正确的写法：<br>一：将res.data存在一个变量中，再把这个变量用this.setData赋值给banner</p>
<p>二：将this改为that</p>
<h3 id="swiper的渲染"><a href="#swiper的渲染" class="headerlink" title="swiper的渲染"></a>swiper的渲染</h3><p>如果把微信：for&#x3D;“”，绑到swiper上<br>那么渲染出来的就是一个又一个swiper，很长，没有想象中的轮播图，<br>正确做法是：将wx：for&#x3D;“</p>
]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>安装vue-cli的坑</title>
    <url>/2019/05/30/%E5%AE%89%E8%A3%85vue-cli%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h1 id="webpack下载失败"><a href="#webpack下载失败" class="headerlink" title="webpack下载失败"></a>webpack下载失败</h1><p>解决方法一：在node安装成功前提下，将npm替换成cnpm<br>替换代码：npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>检查版本：<br>安装webpack：cnpm install webpack -g</p>
<p>解决方法二：检查node版本，<br>检查方法 node -v<br>如果版本低于v6 升级</p>
<h1 id="npm-run-dev失败"><a href="#npm-run-dev失败" class="headerlink" title="npm run dev失败"></a>npm run dev失败</h1><p>显示【’webpack-dev-server’ 不是内部或外部命令，也不是可运行的程序】<br>原因：npm install  这步 有几个文件报错没下载成功<br>解决方法：改用cnpm install 下载<br>扩展：如果是这个报错 也有可能是8080端口被占 </p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>新手向</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序-tabber</title>
    <url>/2019/09/28/%E5%B0%8F%E7%A8%8B%E5%BA%8F-tabber/</url>
    <content><![CDATA[<h3 id="自定义tabbar"><a href="#自定义tabbar" class="headerlink" title="自定义tabbar"></a>自定义tabbar</h3><p>现在项目根目录配置以下入口文件</p>
<p>custom-tab-bar&#x2F;index.js</p>
<p>custom-tab-bar&#x2F;index.json</p>
<p>custom-tab-bar&#x2F;index.wxml</p>
<p>custom-tab-bar&#x2F;index.wxss</p>
<p>因为路径问题所以icon图片一直加载不成功….以下是目录和index.js中正确的路径配置</p>
<p><img data-src="https://img-blog.csdnimg.cn/20190919105155707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NydXNoaF9mdW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list:[&#123;</span><br><span class="line">        &quot;pagePath&quot;:&quot;/pages/index/index&quot;,</span><br><span class="line">        &quot;iconPath&quot;:&quot;/images/菜单栏_首页_未选中.png&quot;,</span><br><span class="line">        &quot;selectedIconPath&quot;:&quot;/images/菜单栏_首页_选中.png&quot;</span><br><span class="line">      &#125;]</span><br></pre></td></tr></table></figure>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>组件所在页面的生命周期,特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。其中可用的生命周期包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pageLifetimes:&#123;</span><br><span class="line">show()&#123;&#125; //	组件所在的页面被展示时执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在page页面的js文件中使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">    pageLifetimes: &#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">      if (typeof this.getTabBar === &#x27;function&#x27; &amp;&amp;</span><br><span class="line">        this.getTabBar()) &#123;</span><br><span class="line">        this.getTabBar().setData(&#123;</span><br><span class="line">          selected:number</span><br><span class="line">          //number对应在custom-tab-bar文件夹中的js中的list列表中data:&#123;  list:[&#123;&#125;] &#125;中list数组的下标</span><br><span class="line">          //getTabBar（）通过 getTabBar 接口获取组件实例，调用 setData 更新选中态。</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>custom-tab-bar&#x2F;index.js中初始化好selected，定义方法switchTab</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switchTab(e)&#123;</span><br><span class="line">			const data=e.currentTarget.dataset</span><br><span class="line">			const url=data.path</span><br><span class="line">			wx.switchTab(&#123;url&#125;)</span><br><span class="line">			this.setData(&#123;</span><br><span class="line">				selected:data.index</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;cover-view wx:for=&quot;&#123;&#123;list&#125;&#125;&quot; wx:key=&quot;index&quot; class=&quot;tab_bar_item&quot; data-path=&quot;&#123;&#123;item.pagePath&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; bindtap=&quot;switchTab&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;cover-image src=&quot;&#123;&#123;selected===index?item.selectedIconPath:item.iconPath&#125;&#125;&quot; class=&quot;image&quot;&gt;</span><br><span class="line">&lt;/cover-imag</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序-建立购物车表</title>
    <url>/2019/10/03/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%BB%BA%E7%AB%8B%E8%B4%AD%E7%89%A9%E8%BD%A6%E8%A1%A8/</url>
    <content><![CDATA[<p>这是我看别人代码总结出来的方法：思路是<br>一，当用户在商品详情页点击加入购物车时，建立一张表，存放在storage空间中。<br>二，每次进入商品详情页时，也就是在onload里面，再次读取这个数组，用getStorage把这个数组赋值给data中我们定义好的shopCatInfo.<br>这是在商品详情页的逻辑。购物车页面的逻辑等下再讲。<br>以下是具体代码<br>一：<br>先定义data</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line"> shopCarInfo: &#123;&#125;,</span><br><span class="line">     shopNum:0,</span><br><span class="line">       buyNumber:0,</span><br><span class="line">     buyNumMin:0,</span><br><span class="line">     buyNumMax:50,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立一张表<br>produce是我请求到的后台商品详情数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var shopCarMap=&#123;&#125;;</span><br><span class="line">     shopCarMap.goods_name=this.data.product.productName;</span><br><span class="line">     shopCarMap.goods_id=this.data.product.productId;</span><br><span class="line">     shopCarMap.pic= this.data.product.productIcon;</span><br><span class="line">     shopCarMap.price= this.data.product.salePrice;</span><br><span class="line">     shopCarMap.number=this.data.buyNumber;</span><br><span class="line">     shopCarMap.active = true;//购物车页面要用到的</span><br><span class="line">     shopCarMap.left=&quot;&quot;;、、购物车页面要用到的</span><br></pre></td></tr></table></figure>
<p>将当前data中的shopCarInfo存入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var shopCarInfo=this.data.shopCarInfo;</span><br><span class="line">//判断一下这个data.shopCarInfo</span><br><span class="line">if(!shopCarInfo.shopNum)&#123;</span><br><span class="line">   shopCarInfo.shopNum=0;</span><br><span class="line">  &#125;</span><br><span class="line">  if(!shopCarInfo.shopList)&#123;</span><br><span class="line">   shopCarInfo.shopList=[];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果加入相同商品</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var hasSameGoodsIndex=-1;//如果又加入相同的商品</span><br><span class="line"></span><br><span class="line">     for(let i=0;i&lt;shopCarInfo.shopList.length;i++)&#123;</span><br><span class="line">      var tmpShopCarMap=shopCarInfo.shopList[i];</span><br><span class="line">      console.log(&#x27;上一次留下的购物车&#x27;+shopCarInfo.shopList[i].goods_name);</span><br><span class="line">      if(tmpShopCarMap.goods_id==shopCarMap.goods_id)</span><br><span class="line">      &#123;//通过id判断购物车里是否已经有和当前加入商品相同的商品</span><br><span class="line">        hasSameGoodsIndex=i;</span><br><span class="line">        shopCarMap.number=shopCarMap.number+tmpShopCarMap.number;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>算一共有多少商品</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//算总的多少件商品 以前的购物车商品数加现在新增加的</span><br><span class="line">     shopCarInfo.shopNum=shopCarInfo.shopNum+this.data.buyNumber;</span><br><span class="line">   console.log(hasSameGoodsIndex);</span><br><span class="line">     if(hasSameGoodsIndex&gt;-1)&#123;</span><br><span class="line">       shopCarInfo.shopList.splice(hasSameGoodsIndex,1,shopCarMap);</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">      shopCarInfo.shopList.push(shopCarMap);</span><br><span class="line">     &#125;</span><br><span class="line">     return shopCarInfo;//返回我们建立好的表</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">addShopCar:function()&#123;</span><br><span class="line">   if(this.data.buyNumber&lt;1)&#123;</span><br><span class="line">     wx.showModal(&#123;</span><br><span class="line">       title:&#x27;提示&#x27;,</span><br><span class="line">       content:&#x27;购买数量不能为0！&#x27;,</span><br><span class="line">       showCancel:false</span><br><span class="line">     &#125;)</span><br><span class="line">     return</span><br><span class="line">   &#125;</span><br><span class="line">   var shopCarInfo=this.buildShopCarInfo();</span><br><span class="line"></span><br><span class="line">   this.setData(&#123;</span><br><span class="line">     shopCarInfo:shopCarInfo,</span><br><span class="line">     shopNum:shopCarInfo.shopNum</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   //写入本地存储</span><br><span class="line">   wx.setStorage(&#123;</span><br><span class="line">     key:&#x27;shopCarInfo&#x27;,</span><br><span class="line">     data:shopCarInfo</span><br><span class="line">   &#125;)</span><br><span class="line">   this.close_popup_tap();</span><br><span class="line">   wx.showToast(&#123;</span><br><span class="line">     title:&#x27;加入购物车&#x27;,</span><br><span class="line">     icon:&#x27;sucess&#x27;,</span><br><span class="line">     duration:2000</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序-用户搜索历史</title>
    <url>/2019/10/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%94%A8%E6%88%B7%E6%90%9C%E7%B4%A2%E5%8E%86%E5%8F%B2/</url>
    <content><![CDATA[<p>今天在写商品搜索时，要记录用户的搜索历史。用setStorage建立一个数组，每次进入商品搜索页面，加载。<br>代码如下：<br>一：一进去先读取history表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onLoad:function()&#123;</span><br><span class="line">    const that=this;</span><br><span class="line">        wx.getStorage(&#123;</span><br><span class="line">      key: &#x27;history&#x27;,</span><br><span class="line">      success: function(res) &#123;</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">         recent_key:res.data</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>二：用户输入完毕，点击搜索时触发这个事件getGoodsList</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;search-input&quot;&gt;</span><br><span class="line">			&lt;icon class=&quot;search-icon&quot; type=&quot;search&quot; size=&quot;16&quot;&gt;&lt;/icon&gt;</span><br><span class="line">			&lt;input type=&quot;text&quot; placeholder=&quot;搜索商品名称&quot; confirm-type=&#x27;search&#x27; value=&quot;&#123;&#123;inputValue&#125;&#125;&quot;  bindconfirm=&quot;getGoodsList&quot; /&gt;</span><br><span class="line">		&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<p>三：在这个事件里存储用户输入的商品名，其实还有发起搜索请求的作用，这里不放了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get_history:function()&#123;</span><br><span class="line">   const that=this;</span><br><span class="line">  wx.getStorage(&#123;</span><br><span class="line">     key: &#x27;history&#x27;,</span><br><span class="line">     success: function(res) &#123;</span><br><span class="line">       that.setData(&#123;</span><br><span class="line">        recent_key:res.data</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"> &#125;,</span><br><span class="line">getGoodsList:function(e)&#123;</span><br><span class="line">   //建立历史记录表</span><br><span class="line">   this.setData(&#123;</span><br><span class="line">     inputValue:e.detail.value</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    const inputValue=this.data.inputValue;</span><br><span class="line">        let history=this.data.recent_key;</span><br><span class="line">        history.push(inputValue)</span><br><span class="line">      </span><br><span class="line">      wx.setStorage(&#123;</span><br><span class="line">       key:&#x27;history&#x27;,</span><br><span class="line">       data:history</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">       this.get_history();//把storage的数据存到data里</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>四，删除history表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;image src=&quot;/images/icon/icon-delete.png&quot; bindtap=&quot;delete_recent&quot;&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  delete_recent:function()&#123;</span><br><span class="line">    const that=this;</span><br><span class="line">  wx.removeStorage(&#123;</span><br><span class="line">  key: &#x27;history&#x27;,</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    that.setData(&#123;</span><br><span class="line">      recent_key:[]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发日记</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
</search>
